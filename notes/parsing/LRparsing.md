# Intro to LR Parsing
LR parsing is a shift-reduce parser which generates the parsing tree from the bottom to the top
as opposed to LL parsing which generates the parse tree from the top to the bottom.
We'll begin with a general form of LR parsing called the Early algorithm, and then specialize to LR grammars
where it is more efficient.

## LR(0) items
The key concept underlying LR parsing is the notion of an LR-item which consists of a grammar rule
with a "dot" added to the right hand side

$$A \rightarrow \alpha . \beta$$

It corresponds to a derivation with root A where the symbols in $\alpha$ have been expanded to terminals.
Either or both of $\alpha$ and $\beta$ can be empty (i.e. $\epsilon$)

Consider the following left-recursive unambiguous grammar for arithmetic expressions
```
S -> E $
E -> E + T
E -> T
T -> T * F
T -> F
F -> v
F -> (E)
```
Below is a parse tree for the string "(v+v+v)*(v+v)$"
<img src="./LRParseTree.jpg" alt="LR Parse Tree" width="50%">

At each position of the string (from 0 before the first character to 13 after the last character)
we can associate a set of LR items for that parse tree. We will show how to generate these sets of LR items
even when we've only seen the a prefix of the string!

We will let $N_i$ be the set of LR(0)-items at position i.
We will also attach to each item $A\rightarrow \alpha . \beta$ the index of the string at which $\alpha$ starts.

```
N0 =
S -> . E $     0
E -> . T       0
T -> . T + F   0
T -> . F       0
F -> . ( E )   0
```
These correspond to the first five steps of a top-down leftmost derivation of the string
``` 
S -> E$ -> T$ -> T+F$ -> F+F$ => (E)+F$
```
After we see the left parenthesis '(' we go to state N1 which is the set of LR-items active at the beginning of the parse
```
N1 =
F -> ( . E )  0
E -> . E + T  1
E -> . T      1
T -> . F      1
F -> . V      1
```
After seeing the v we can reduce v to F and to T and to E and get
```
N2 =
F -> v .      1
T -> F .      1
E -> T .      1
E -> E . + T  1
```
Next we see the + and advance to state N3
```
N3 =
E -> E + . T  1
T -> . F      3
F -> . v      3
```
after we see the v at position 3 we go to N4
```
E -> E + T .  1
E -> E . + T  1
```
Observe that the first item ``` E -> E + T .  1```
indicates that we were looking for a E at node 1 in the rule ```E -> . E + T  1```
and since we've found that E we can advance the dot over the E to get
```E-> E . + T  1```

Try to calculate all of the rest of these node sets...
You can do it out of order, for example
```
N8 =
T -> T * . F  0
F -> . ( E )  8
```
The idea behind LR parsing is to generate LR sets by using two operations
* **shift** - when we move from N(i) to N(i+1) by scanning a terminal $t$ we
  find each LR item in N(i) which was expecting a "t", i.e. of the form
  * $A\rightarrow \alpha . t \beta,   j$
  * and advance the dot past t and put this new rule in N(i+1)
  * $A\rightarrow \alpha t . \beta,   j$
* **closure** for each item of the form $A \rightarrow \alpha . N \beta$ in N(i+1)
  and each rule $N\rightarrow \gamma$ and  $N\rightarrow . \gamma, i+1$ to N(i+1)
  and repeat until there is no change
* **reduce** for each item of the form $A \rightarrow \gamma .,  j$ find all LR-items
  in N(j) which were expecting an "A", and shift the dot over the A and add the new production to N(i+1)
  that is find $B\rightarrow \alpha . A \beta, r$ in N(j)$ and add $B\rightarrow \alpha A . \beta$ to N(i+1)

Repeat the closure and reduce until there is no change and this is the state N(i+1).
It is not hard to see that each of these steps takes time O(n^2) where $n$ is the length of the string being parsed.
If the rule $S\rightarrow E \$$ is in the last LR set N(n), then the string is in the language, otherwise it is not.

## Practice 1
Let's try this with the simpler grammar
```
S -> E $
E -> E + E
E -> v
```
and try to parse "v + v + v" which has two parses...
```
N0 =
S -> . E $     0
E -> . E + E   0
E -> . v       0
```
where we get ```S-> . E $``` as S is the start symbol
and the other two items we get by prediction.

Next we see the "v" so we can shift it 
```
Shift(v) =>
N1 =
E -> v .       0
E -> E . + E   0
E -> E . $     0
```
where the first LR items comes from a shift
and the next two come by reducing and finding LR items in N0 that expect an E
Next we see a "+ so we can shift the second rule, 
If we had seen a "$" we could have parsed "v $" into an S, but we saw a "+" so
```
Shift(+) =>
N2 =
E -> E + . E  0
E -> . E + E  2
E -> . v      2
```
Next we see an E so
```
Reduce(Shift(v)) =>
N3 =
E -> v .     2
E -> E . + E 2
E -> E + E . 0
S -> E . $
E -> E . + E
```
where the second and third items are generated by the reduce operation applied to ```E->v.  2```
and the fourth and fifth are from reducing ```E -> E + E . 0```

You can try and complete this. Notice if the next symbol was '$' we would shift to ```S-> E $ . 0``` which would accept ```v+v$```



## Practice 2
Let's try it with 
```
S -> E $
E -> E + T
E -> v
E -> ( E )
```
and try to parse "( v + v ) + v + v"
and 











